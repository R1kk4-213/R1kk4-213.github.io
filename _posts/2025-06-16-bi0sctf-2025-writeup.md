---
title: bi0sCTF 2025 Writeup
date: 2025-06-16 23:00 +0700
categories: [Cybersecurity, CTF]
tags: [writeup, bi0sCTF, "2025"]
media_subpath: /assets/bi0sCTF2025
---

## Introduction

To be honest, I haven't solved many challenges during the CTF, but I find them very interesting. So, I decided to challenge myself by redoing the problems and writing a write-up for them.

This is the link to the source Code of all Web Challenges: [Link](https://github.com/teambi0s/bi0sCTF/tree/main/2025/WEB)

## myFlaskApp

### Analyze

First, let's analyze the features currently available:

- A register/login page is implemented.
- Users can update their bio.
![alt text](update_bio.png)

Next, we'll take a closer look at the code.

### Code Analysis

- The application is written in Python using the Flask framework and MongoDB for data storage.
- One of the first things that stands out is the presence of `bot.py` and a function related to Content Security Policy (CSP).
  This suggests there may be a client-side challenge involving a potential CSP bypass â€” that's my initial hypothesis.



```python
from playwright.sync_api import sync_playwright
import os

def visit(url):
    admin_password = os.getenv("ADMIN_PASSWORD", "admin")
    flag = os.getenv("FLAG", "bi0sctf{testflag}")

    with sync_playwright() as p:

        browser = p.chromium.launch(
            headless=True,
            args=[
                "--no-sandbox",
                "--disable-dev-shm-usage",
                "--disable-gpu"
            ]
        )
        page = browser.new_page()

        try:

            page.goto("http://localhost:5000/login", wait_until="networkidle")
            page.wait_for_timeout(1000)

            # Fill out the login form
            page.fill("#username", "admin")
            page.fill("#password", admin_password)
            page.click("button[type='submit']")
            print("Logged in as admin")

            page.wait_for_timeout(1000)  

            page.context.add_cookies([{
                'name': 'flag',
                'value': flag,
                'domain': 'localhost',
                'path': '/',
                'httpOnly': False,
                'sameSite': 'Lax',
                'secure': False
            }])

            print(f"Visiting URL: {url}")
            page.goto(url, wait_until="networkidle")
            page.wait_for_timeout(3000)  

        except Exception as e:
            print(f"Bot error: {str(e)}")
        finally:
            browser.close()
```
{: file="bot.py"}

```python

# set CSP header for all responses
@app.after_request
def set_csp(response):
    response.headers["Content-Security-Policy"] = (
        "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' ;"
    )
    return response

```
{: file="app.py"}

- So based on that i will first analyze the `bot.py` file.
    - Bot will login as admin with provided credentials.
    - The flag will be set as a cookie named `flag`. 
    - The bot will then visit the URL provided as an argument.
```python
            page.context.add_cookies([{
                'name': 'flag',
                'value': flag,
                'domain': 'localhost',
                'path': '/',
                'httpOnly': False,
                'sameSite': 'Lax',
                'secure': False
            }])
```

{: file="bot.py"}


But in route `/report`
```python


@app.route("/report", methods=["GET", "POST"])
@login_required
def report():
    if request.method == "GET":
        return render_template("report.html")

    data = request.json
    name = data.get("name")
    if not name:
        return jsonify({"error": "Name is required"}), 400
    url = f"http://localhost:5000/users?name={name}"
    try:
        visit(url)
        return jsonify({"message": f"Bot visited /users?name={name}"}), 200
    except Exception as e:
        return jsonify({"error": f"Bot failed to visit URL: {str(e)}"}), 500

```
{: file="app.py"}

we can only control the `name` parameter, which is used to construct the URL for the bot to visit. The bot will then visit `/users?name={name}`.


Now looking at route `/users`
```python
@app.route("/users")
@login_required
@check_admin
def users():
    return render_template("users.html")
```
{: file="app.py"}


The `/users` route is protected by the `@check_admin` decorator, which means only admin users can access it. The bot will visit this route with the `name` parameter appended to the URL.
and the `users.html` template is rendered, which contains the following code:

```html

<!DOCTYPE html>
<html>
    <head>
        <title>Users</title>
        <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
        <script src="{{ url_for('static', filename='index.js') }}"></script>
        <script src="{{ url_for('static', filename='users.js') }}"></script>
    </head>
    <body>
        <h1>Users</h1>
        <div id="frames"></div>
    </body>
```
{: file="users.html"}

Seem nothing special here, excep there are 2 js files included: `index.js` and `users.js`. Let's take a look at `users.js`:

```javascript
document.addEventListener("DOMContentLoaded", async function() {
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    // get url serach params
    const urlParams = new URLSearchParams(window.location.search);
    const name = urlParams.get('name');
    if (name) {
        fetch(`/api/users?name=${name}`)
            .then(response => response.json())
            .then(data => {
                frames = data.map(user => {
                    return `
                        <iframe src="/render?${Object.keys(user).map((i)=> encodeURI(i+"="+user[i]).replaceAll('&','')).join("&")}"></iframe>
                    `;
                }).join("");
                document.getElementById("frames").innerHTML = frames;
            })
            .catch(error => {
               console.log("Error fetching user data:", error);
            })
        
    }
    if(window.name=="admin"){
            js = urlParams.get('js');
            if(js){
                eval(js);
            }
            
    }
    
})
```
{: file="users.js"}

So in this js file, we can see that it fetches user data from the `/api/users?name=${name}` endpoint and then renders it in iframes. The `name` parameter is taken from the URL search parameters.
But the most interesting part is the `if(window.name=="admin")` block, which checks if the window name is "admin". If it is, it evaluates the `js` parameter from the URL. This means we can inject JavaScript code into the page by manipulating the `name` parameter. And after use CSP evaluator, i think this must be a way to bypass the CSP above.

But the hard thing is, in `index.js`
